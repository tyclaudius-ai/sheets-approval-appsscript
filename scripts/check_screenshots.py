#!/usr/bin/env python3
"""Check whether docs/screenshots/*.png are true screenshots, real-ish mocks, or placeholder copies.

This repo includes SVG placeholders and a generated PNG set under:
  docs/screenshots/png/*.png

The landing page references docs/screenshots/*.png.
During development, those files may be:
  - exact placeholder copies (bad)
  - "real-ish" mocks generated by scripts/generate_realish_screenshots.py (ok for docs, not ideal for listings)
  - true screenshots captured from a real Google Sheet (preferred)

Detection:
  1) PLACEHOLDER: sha256(docs/screenshots/<name>.png) == sha256(docs/screenshots/png/<name>.png)
  2) REALISH: sha256(docs/screenshots/<name>.png) matches docs/screenshots/realish-hashes.json

Exit codes:
  0: ok (or non-failing findings)
  2: placeholders found and --fail-on-placeholders
  3: missing files
  4: real-ish screenshots found and --fail-on-realish
"""

from __future__ import annotations

import argparse
import hashlib
import json
import os
import shutil
import subprocess
from datetime import datetime, timezone
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
TOP_DIR = ROOT / "docs" / "screenshots"
PLACEHOLDER_DIR = TOP_DIR / "png"
REALISH_HASHES_PATH = TOP_DIR / "realish-hashes.json"
MANIFEST_PATH = TOP_DIR / "manifest.json"

# Back-compat fallback if manifest.json is missing/corrupt.
FALLBACK_NAMES = [
    "01-menu.png",
    "02-requests-pending.png",
    "03-approved-row.png",
    "04-audit-entry.png",
    "05-reapproval-required.png",
    "06-help-sidebar.png",
]


def load_required_names() -> list[str]:
    """Load required screenshot filenames from docs/screenshots/manifest.json.

    Keeping the shotlist in one place prevents drift between:
      - the landing-page/gallery renderer (manifest)
      - this validator/checker
      - docs that reference the required filenames
    """
    if not MANIFEST_PATH.exists():
        return list(FALLBACK_NAMES)
    try:
        payload = json.loads(MANIFEST_PATH.read_text(encoding="utf-8"))
        items = payload.get("items")
        if not isinstance(items, list):
            return list(FALLBACK_NAMES)
        names: list[str] = []
        for it in items:
            if not isinstance(it, dict):
                continue
            f = it.get("file")
            if isinstance(f, str) and f.endswith(".png"):
                names.append(f)
        # If manifest is present but empty/malformed, fall back.
        return names or list(FALLBACK_NAMES)
    except Exception:
        return list(FALLBACK_NAMES)


# The required filenames (in display order).
NAMES = load_required_names()


def sha256(p: Path) -> str:
    h = hashlib.sha256()
    with p.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def load_realish_hashes() -> dict[str, str]:
    if not REALISH_HASHES_PATH.exists():
        return {}
    try:
        payload = json.loads(REALISH_HASHES_PATH.read_text(encoding="utf-8"))
        files = payload.get("files")
        if isinstance(files, dict):
            out: dict[str, str] = {}
            for k, v in files.items():
                if isinstance(k, str) and isinstance(v, str) and len(v) >= 32:
                    out[k] = v
            return out
    except Exception:
        return {}
    return {}


def sips_px(p: Path) -> tuple[int | None, int | None]:
    """Best-effort pixel dimensions (macOS only). Returns (w, h) or (None, None)."""
    if shutil.which("sips") is None:
        return (None, None)
    try:
        proc = subprocess.run(
            ["sips", "-g", "pixelWidth", "-g", "pixelHeight", str(p)],
            check=False,
            capture_output=True,
            text=True,
        )
        out = (proc.stdout or "") + "\n" + (proc.stderr or "")
        w: int | None = None
        h: int | None = None
        for line in out.splitlines():
            line = line.strip()
            if line.startswith("pixelWidth:"):
                try:
                    w = int(line.split(":", 1)[1].strip())
                except Exception:
                    pass
            if line.startswith("pixelHeight:"):
                try:
                    h = int(line.split(":", 1)[1].strip())
                except Exception:
                    pass
        return (w, h)
    except Exception:
        return (None, None)


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--fail-on-placeholders",
        action="store_true",
        help="Exit non-zero if any top-level screenshot PNG is still a placeholder copy.",
    )
    ap.add_argument(
        "--fail-on-realish",
        action="store_true",
        help="Exit non-zero if any top-level screenshot PNG is still a 'real-ish' mock (generated).",
    )
    ap.add_argument(
        "--require-real-screenshots",
        action="store_true",
        help="Convenience flag: equivalent to --fail-on-placeholders --fail-on-realish.",
    )
    ap.add_argument(
        "--require-marketplace",
        action="store_true",
        help=(
            "Stricter convenience gate for marketplace readiness: requires real screenshots (no placeholders/real-ish mocks) "
            "AND enforces the standard pixel size (defaults to 1688x1008). Equivalent to: "
            "--require-real-screenshots --require-pixels 1688x1008 --fail-on-dim-mismatch."
        ),
    )
    ap.add_argument(
        "--json",
        action="store_true",
        help="Emit machine-readable JSON (still prints nothing else).",
    )
    ap.add_argument(
        "--show-info",
        action="store_true",
        help="Print file size + best-effort pixel dimensions for each screenshot (uses macOS `sips` if available).",
    )
    ap.add_argument(
        "--require-pixels",
        metavar="WxH",
        help=(
            "Optional: require all screenshots to match an exact pixel size (e.g., 1280x800). "
            "When set, the JSON/report outputs include mismatches, and --fail-on-dim-mismatch can gate CI."
        ),
    )
    ap.add_argument(
        "--fail-on-dim-mismatch",
        action="store_true",
        help="Exit non-zero (5) if any screenshot does not match --require-pixels (or dimensions cannot be determined).",
    )
    ap.add_argument(
        "--shotlist",
        action="store_true",
        help="Print the required screenshot filenames as a capture checklist (useful before doing a real screenshot pass).",
    )
    ap.add_argument(
        "--next",
        action="store_true",
        help=(
            "Print a short prioritized 'what to do next' list (missing/placeholder/real-ish screenshots) "
            "with suggested commands."
        ),
    )
    ap.add_argument(
        "--report-md",
        metavar="PATH",
        help=(
            "Write a Markdown status report to PATH (use '-' for stdout). "
            "Includes shotlist + current classification (missing/placeholder/real-ish/ok)."
        ),
    )
    ap.add_argument(
        "--report-html",
        metavar="PATH",
        help=(
            "Write an HTML status report to PATH (use '-' for stdout). "
            "Includes thumbnails + current classification (missing/placeholder/real-ish/ok)."
        ),
    )
    ap.add_argument(
        "--report-json",
        metavar="PATH",
        help=(
            "Write a machine-readable JSON status report to PATH (use '-' for stdout). "
            "Equivalent payload to --json, but doesn't suppress normal output unless you also pass --json."
        ),
    )
    ap.add_argument(
        "--report-jaxon",
        metavar="PATH",
        help=(
            "Write a short human-focused 'next actions' Markdown note (good to paste into chat) to PATH. "
            "Default suggestion: docs/screenshots/JAXON_NEXT_ACTIONS.md"
        ),
    )
    ap.add_argument(
        "--reveal",
        action="store_true",
        help=(
            "macOS: reveal screenshot files in Finder (uses `open -R`). "
            "Reveals any files that are placeholders or real-ish mocks (i.e., the ones you should replace)."
        ),
    )
    ap.add_argument(
        "--open-guides",
        action="store_true",
        help="macOS: open the quick-run + shotlist + cheatsheet guides in the default app.",
    )
    args = ap.parse_args()

    def parse_pixels(s: str) -> tuple[int, int] | None:
        s = (s or "").strip().lower().replace(" ", "")
        if not s:
            return None
        if "x" not in s:
            return None
        a, b = s.split("x", 1)
        try:
            w = int(a)
            h = int(b)
            if w <= 0 or h <= 0:
                return None
            return (w, h)
        except Exception:
            return None

    # Convenience: marketplace readiness gate.
    if args.require_marketplace:
        args.require_real_screenshots = True
        if not args.require_pixels:
            args.require_pixels = "1688x1008"
        args.fail_on_dim_mismatch = True

    required_pixels = parse_pixels(args.require_pixels) if args.require_pixels else None

    # Convenience: 'real screenshots' means neither placeholders nor known generated "real-ish" mocks.
    if args.require_real_screenshots:
        args.fail_on_placeholders = True
        args.fail_on_realish = True

    if args.shotlist and not args.json:
        print("[screenshots] Capture shotlist (required filenames):")
        for n in NAMES:
            print(f"  - docs/screenshots/{n}")
        print("\nGuides:")
        print("  - Quick run: docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md")
        print("  - Shotlist + framing: docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md")
        print("  - Cheatsheet: docs/screenshots/CAPTURE-CHEATSHEET.md")
        return 0

    missing: list[str] = []
    placeholders: list[str] = []
    realish: list[str] = []

    dim_mismatch: list[str] = []
    dim_unknown: list[str] = []

    info: dict[str, dict[str, int | None]] = {}

    realish_hashes = load_realish_hashes()

    for name in NAMES:
        top = TOP_DIR / name
        ph = PLACEHOLDER_DIR / name

        if not top.exists():
            missing.append(str(top.relative_to(ROOT)))
            continue
        if not ph.exists():
            missing.append(str(ph.relative_to(ROOT)))
            continue

        try:
            top_h = sha256(top)
            if top_h == sha256(ph):
                placeholders.append(name)
            elif realish_hashes.get(name) == top_h:
                realish.append(name)

            w, h = sips_px(top)
            try:
                size = top.stat().st_size
            except Exception:
                size = None
            info[name] = {"bytes": size, "width": w, "height": h}

            if required_pixels:
                rw, rh = required_pixels
                if w is None or h is None:
                    dim_unknown.append(name)
                elif w != rw or h != rh:
                    dim_mismatch.append(name)
        except OSError:
            missing.append(name)

    needs_attention: list[str] = []
    # Order: missing first (must exist), then placeholders, then known real-ish mocks, then pixel-dimension mismatches.
    needs_attention += [f"docs/screenshots/{Path(m).name}" for m in missing]
    needs_attention += [f"docs/screenshots/{n}" for n in placeholders]
    needs_attention += [f"docs/screenshots/{n}" for n in realish]
    needs_attention += [f"docs/screenshots/{n}" for n in dim_unknown]
    needs_attention += [f"docs/screenshots/{n}" for n in dim_mismatch]

    def print_next() -> None:
        if not args.next or args.json:
            return
        if not needs_attention:
            print("[screenshots] NEXT: nothing to do — screenshots look real.")
            return

        print("[screenshots] NEXT actions (replace these files with true Google Sheets captures):")
        for p in needs_attention[:10]:
            print(f"  - {p}")
        print("")
        print("Suggested flow:")
        print("  1) Open guides: python3 scripts/check_screenshots.py --open-guides")
        print("  2) (macOS) Reveal files to replace: python3 scripts/check_screenshots.py --reveal")
        print("  3) After capturing, install+optimize: python3 scripts/install_real_screenshots.py --from ~/Desktop --check --optimize")
        print("  4) Re-check gate: python3 scripts/check_screenshots.py --require-real-screenshots")

    print_next()

    def write_report_md() -> None:
        if not args.report_md:
            return

        # For the Markdown report, treat any missing/placeholder/real-ish/dimension mismatch as "needs work".
        # (CLI exit codes may still be gated by --fail-on-* flags.)
        ok = (not missing) and (not placeholders) and (not realish)
        if required_pixels and (dim_unknown or dim_mismatch):
            ok = False

        lines: list[str] = []
        lines.append("# Real screenshots status")
        lines.append("")
        lines.append(f"Generated by `python3 scripts/check_screenshots.py --report-md {args.report_md}`")
        lines.append("")
        lines.append(f"Status: {'✅ OK' if ok else '⚠️ Needs work'}")
        lines.append("")

        lines.append("## Required shotlist")
        for n in NAMES:
            lines.append(f"- `docs/screenshots/{n}`")
        lines.append("")

        if not ok:
            lines.append("## Next actions")
            lines.append("Replace these with true Google Sheets captures (not placeholders / not generated real-ish mocks).")
            for p in needs_attention[:6]:
                lines.append(f"- `{p}`")
            lines.append("")
            lines.append("Suggested flow:")
            lines.append("1. Read: `docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md`")
            lines.append("2. Capture using: `docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md`")
            lines.append("3. Install: `python3 scripts/install_real_screenshots.py --from ~/Desktop --check --optimize`")
            lines.append("4. Gate: `python3 scripts/check_screenshots.py --require-real-screenshots`")
            lines.append("")

        if missing:
            lines.append("## Missing")
            for m in missing:
                lines.append(f"- `{m}`")
            lines.append("")

        if placeholders:
            lines.append("## Placeholder copies detected")
            lines.append("These files are exact copies of `docs/screenshots/png/*.png` placeholders.")
            for n in placeholders:
                lines.append(f"- `docs/screenshots/{n}`")
            lines.append("")

        if realish:
            lines.append("## 'Real-ish' generated screenshots detected")
            lines.append(
                "These match the known generated hashes in `docs/screenshots/realish-hashes.json` "
                "(good for docs; not ideal for marketplace listings)."
            )
            for n in realish:
                lines.append(f"- `docs/screenshots/{n}`")
            lines.append("")

        if required_pixels and (dim_unknown or dim_mismatch):
            lines.append("## Pixel dimension mismatches")
            lines.append(f"Required: `{required_pixels[0]}x{required_pixels[1]}`")
            if dim_unknown:
                lines.append("### Unknown pixel dimensions")
                for n in dim_unknown:
                    lines.append(f"- `docs/screenshots/{n}`")
            if dim_mismatch:
                lines.append("### Mismatched pixels")
                for n in dim_mismatch:
                    v = info.get(n) or {}
                    w = v.get("width")
                    h = v.get("height")
                    got = f"{w}×{h}" if (w and h) else "(unknown)"
                    lines.append(f"- `docs/screenshots/{n}` (got {got})")
            lines.append("")

        # Always include a compact per-file status table (faster than scanning sections).
        lines.append("## Files")
        lines.append("")
        lines.append("| File | Status | Bytes | Pixels |")
        lines.append("|---|---|---:|---:|")
        missing_names = {Path(m).name for m in missing}
        for name in NAMES:
            status = "OK"
            if name in missing_names:
                status = "MISSING"
            elif name in placeholders:
                status = "PLACEHOLDER"
            elif name in realish:
                status = "REALISH"

            v = info.get(name) or {}
            b = v.get("bytes")
            w = v.get("width")
            h = v.get("height")
            bs = f"{b}" if b is not None else "—"
            px = f"{w}×{h}" if (w and h) else "—"
            lines.append(f"| `{name}` | {status} | {bs} | {px} |")
        lines.append("")

        lines.append("## How to capture & install")
        lines.append("- Quick run: `docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md`")
        lines.append("- Shotlist + framing: `docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md`")
        lines.append("- Cheatsheet: `docs/screenshots/CAPTURE-CHEATSHEET.md`")
        lines.append("- Install helper: `python3 scripts/install_real_screenshots.py --from ~/Desktop --check --optimize`")
        lines.append("- Optional capture pack zip: `python3 scripts/make_real_screenshot_capture_pack.py`")
        lines.append("")

        lines.append("## File info (best-effort)")
        lines.append("Pixel dimensions use macOS `sips` when available.")
        lines.append("")
        for name in NAMES:
            v = info.get(name) or {}
            b = v.get("bytes")
            w = v.get("width")
            h = v.get("height")
            px = f"{w}×{h}" if (w and h) else "(px unknown)"
            bs = f"{b}" if b is not None else "(bytes unknown)"
            lines.append(f"- `{name}`: {bs} bytes, {px}")

        out = "\n".join(lines).rstrip() + "\n"

        if args.report_md == "-":
            print(out)
            return
        Path(args.report_md).write_text(out, encoding="utf-8")

    write_report_md()

    def write_report_html() -> None:
        if not args.report_html:
            return

        ok = (not missing) and (not placeholders) and (not realish)
        if required_pixels and (dim_unknown or dim_mismatch):
            ok = False

        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace('"', "&quot;")
            )

        missing_names = {Path(m).name for m in missing}

        output_dir = (ROOT if args.report_html == "-" else Path(args.report_html).resolve().parent)

        rows: list[str] = []
        for name in NAMES:
            status = "OK"
            if name in missing_names:
                status = "MISSING"
            elif name in placeholders:
                status = "PLACEHOLDER"
            elif name in realish:
                status = "REALISH"

            v = info.get(name) or {}
            b = v.get("bytes")
            w = v.get("width")
            h = v.get("height")
            bs = f"{b}" if b is not None else "—"
            px = f"{w}×{h}" if (w and h) else "—"

            img_path = TOP_DIR / name
            rel = os.path.relpath(str(img_path), str(output_dir))
            if status != "MISSING":
                img_cell = (
                    f'<a href="{esc(rel)}" target="_blank">'
                    f'<img src="{esc(rel)}" style="max-width: 320px; border: 1px solid #ddd;" />'
                    f"</a>"
                )
            else:
                img_cell = "(missing)"

            rows.append(
                "\n".join(
                    [
                        "<tr>",
                        f"  <td><code>{esc(name)}</code></td>",
                        f"  <td>{esc(status)}</td>",
                        f"  <td style=\"text-align:right\">{esc(bs)}</td>",
                        f"  <td style=\"text-align:right\">{esc(px)}</td>",
                        f"  <td>{img_cell}</td>",
                        "</tr>",
                    ]
                )
            )

        next_list = "".join([f"<li><code>{esc(p)}</code></li>" for p in needs_attention[:10]])
        if ok:
            next_block = ""
        else:
            next_block = (
                "<h2>Next actions</h2>\n"
                "<p>Replace these with true Google Sheets captures (not placeholders / not generated real-ish mocks).</p>\n"
                f"<ul>{next_list}</ul>\n"
                "<p>Suggested flow:</p>\n"
                "<ol>\n"
                "  <li>Read: <code>docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md</code></li>\n"
                "  <li>Capture using: <code>docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md</code></li>\n"
                "  <li>Install: <code>python3 scripts/install_real_screenshots.py --from ~/Desktop --check --optimize</code></li>\n"
                "  <li>Gate: <code>python3 scripts/check_screenshots.py --require-real-screenshots</code></li>\n"
                "</ol>\n"
            )

        html = "\n".join(
            [
                "<!doctype html>",
                "<html>",
                "<head>",
                "  <meta charset=\"utf-8\" />",
                "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />",
                "  <title>Real screenshots status</title>",
                "  <style>",
                "    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 20px; }",
                "    code { background: #f6f8fa; padding: 2px 4px; border-radius: 4px; }",
                "    table { border-collapse: collapse; width: 100%; }",
                "    th, td { border: 1px solid #eee; padding: 8px; vertical-align: top; }",
                "    th { background: #fafafa; text-align: left; }",
                "    .ok { color: #116329; font-weight: 600; }",
                "    .bad { color: #b62324; font-weight: 600; }",
                "  </style>",
                "</head>",
                "<body>",
                "  <h1>Real screenshots status</h1>",
                f"  <p>Generated by <code>python3 scripts/check_screenshots.py --report-html {esc(args.report_html)}</code></p>",
                f"  <p>Status: <span class=\"{ 'ok' if ok else 'bad' }\">{ 'OK' if ok else 'NEEDS WORK' }</span></p>",
                next_block,
                "  <h2>Files</h2>",
                "  <table>",
                "    <thead>",
                "      <tr><th>File</th><th>Status</th><th>Bytes</th><th>Pixels</th><th>Preview</th></tr>",
                "    </thead>",
                "    <tbody>",
                "\n".join(rows),
                "    </tbody>",
                "  </table>",
                "  <h2>Guides</h2>",
                "  <ul>",
                "    <li><code>docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md</code></li>",
                "    <li><code>docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md</code></li>",
                "    <li><code>docs/screenshots/CAPTURE-CHEATSHEET.md</code></li>",
                "  </ul>",
                "</body>",
                "</html>",
                "",
            ]
        )

        if args.report_html == "-":
            print(html)
            return
        Path(args.report_html).write_text(html, encoding="utf-8")

    write_report_html()

    def write_report_jaxon() -> None:
        if not args.report_jaxon:
            return

        ok = (not missing) and (not placeholders) and (not realish)
        if required_pixels and (dim_unknown or dim_mismatch):
            ok = False
        lines: list[str] = []
        lines.append("# Jaxon — Real screenshots next actions")
        lines.append("")
        lines.append(
            "This note is generated by `python3 scripts/check_screenshots.py --report-jaxon <PATH>` "
            "and is meant to be copy/pasted into chat."
        )
        lines.append("")
        # Intentionally omit a generated timestamp so this file is stable in git unless the
        # actual action items change.
        lines.append(f"Status: {'OK' if ok else 'NEEDS REAL SCREENSHOTS'}")
        lines.append("")

        if ok:
            lines.append("Nothing needed — all 6 listing screenshots look like real captures.")
        else:
            lines.append("## Do this")
            lines.append("Target time: ~10 minutes (once the Apps Script authorization is already done).")
            if required_pixels:
                lines.append(f"Screenshot size gate: **{required_pixels[0]}×{required_pixels[1]}** pixels.")
            else:
                lines.append("Recommended size: **1688×1008** pixels (consistent marketplace framing).")
            lines.append("")
            lines.append("1) Fastest: run the guided capture pack")
            lines.append("   - Double-click: `CAPTURE_MAC.command` (repo root)")
            lines.append("2) Manual flow")
            lines.append("   - Read: `docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md`")
            lines.append("   - Capture: `docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md`")
            lines.append("   - Install+optimize: `python3 scripts/install_real_screenshots.py --from ~/Desktop --check --optimize`")
            lines.append("   - Gate: `python3 scripts/check_screenshots.py --require-real-screenshots`")
            lines.append("")
            lines.append("Optional 1-command pipeline (install → gate → optimize → render gallery):")
            lines.append("```bash")
            lines.append("python3 scripts/screenshots_pipeline.py --from ~/Desktop --check --require-real-screenshots --optimize --width 1400 --render-gallery")
            lines.append("```")
            lines.append("")

            lines.append("## Files to replace")
            for p in needs_attention[:10]:
                lines.append(f"- `{p}`")
            lines.append("")

        out = "\n".join(lines).rstrip() + "\n"
        Path(args.report_jaxon).write_text(out, encoding="utf-8")

    write_report_jaxon()

    # Optional helpers for a fast real-screenshot pass (macOS only).
    if (args.reveal or args.open_guides) and shutil.which("open") is not None:
        try:
            if args.open_guides:
                for rel in [
                    "docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md",
                    "docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md",
                    "docs/screenshots/CAPTURE-CHEATSHEET.md",
                ]:
                    p = ROOT / rel
                    if p.exists():
                        subprocess.run(["open", str(p)], check=False)

            if args.reveal:
                # Reveal only the files that need replacement (placeholder or known real-ish).
                for n in sorted(set(placeholders + realish)):
                    p = TOP_DIR / n
                    if p.exists():
                        subprocess.run(["open", "-R", str(p)], check=False)
        except Exception:
            pass

    def build_payload() -> dict:
        dim_ok = True
        if required_pixels and (dim_unknown or dim_mismatch):
            dim_ok = False

        ok_strict = (not missing) and (not placeholders) and (not realish) and dim_ok
        ok_by_flags = (
            (not missing)
            and (not args.fail_on_placeholders or not placeholders)
            and (not args.fail_on_realish or not realish)
            and (not args.fail_on_dim_mismatch or dim_ok)
        )

        generated_at = datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")

        return {
            "generatedAt": generated_at,
            # Strict truth: are the listing screenshots fully ready (no placeholders, no known generated mocks,
            # and pixel dimensions match if required)?
            "ok": ok_strict,
            # Back-compat / diagnostics: reflects whether the current invocation would consider the state OK
            # given fail-on flags.
            "okByFlags": ok_by_flags,
            "missing": missing,
            "placeholders": [f"docs/screenshots/{n}" for n in placeholders],
            "realish": [f"docs/screenshots/{n}" for n in realish],
            "requiredPixels": (f"{required_pixels[0]}x{required_pixels[1]}" if required_pixels else None),
            "dimUnknown": [f"docs/screenshots/{n}" for n in dim_unknown],
            "dimMismatch": [f"docs/screenshots/{n}" for n in dim_mismatch],
            "shotlist": [f"docs/screenshots/{n}" for n in NAMES],
            "needsAttention": needs_attention,
            "info": {
                k: {"bytes": v.get("bytes"), "width": v.get("width"), "height": v.get("height")}
                for k, v in info.items()
            },
            "infoNote": "Pixel dimensions are best-effort (macOS uses `sips`).",
        }

    if args.report_json:
        payload = build_payload()
        out = json.dumps(payload, indent=2) + "\n"
        if args.report_json.strip() == "-":
            print(out, end="")
        else:
            # Avoid needless churn: if the only diff is generatedAt, keep the existing file as-is.
            out_path = Path(args.report_json)
            if out_path.exists():
                try:
                    existing = json.loads(out_path.read_text(encoding="utf-8"))
                    if isinstance(existing, dict) and "generatedAt" in existing:
                        payload_stable = dict(payload)
                        payload_stable["generatedAt"] = existing.get("generatedAt")
                        if payload_stable == existing:
                            out = ""  # signal: no write
                except Exception:
                    pass
            if out:
                out_path.write_text(out, encoding="utf-8")

    if args.json:
        payload = build_payload()
        print(json.dumps(payload, indent=2))
        if missing:
            return 3
        if placeholders and args.fail_on_placeholders:
            return 2
        if realish and args.fail_on_realish:
            return 4
        if (dim_unknown or dim_mismatch) and args.fail_on_dim_mismatch:
            return 5
        return 0

    if args.show_info and not missing:
        print("[screenshots] INFO (size + pixels):")
        for name in NAMES:
            v = info.get(name) or {}
            b = v.get("bytes")
            w = v.get("width")
            h = v.get("height")
            px = f"{w}×{h}" if (w and h) else "(px unknown)"
            bs = f"{b}" if b is not None else "(bytes unknown)"
            print(f"  - {name}: {bs} bytes, {px}")
        print("")

    if missing:
        print("[screenshots] MISSING files:")
        for m in missing:
            print(f"  - {m}")
        return 3

    if placeholders:
        print("[screenshots] PLACEHOLDER copies detected (top-level PNG matches placeholder PNG):")
        for n in placeholders:
            print(f"  - docs/screenshots/{n}")

        print("\nNext steps:")
        print("  - Quick run: docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md")
        print("  - Shotlist + framing: docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md")
        print("  - Cheatsheet: docs/screenshots/CAPTURE-CHEATSHEET.md")
        print("  - Helper installer: python3 scripts/install_real_screenshots.py --from ~/Desktop")
        print("  - Optional capture pack zip: python3 scripts/make_real_screenshot_capture_pack.py")

        if args.fail_on_placeholders:
            return 2
        return 0

    if realish:
        print("[screenshots] WARNING — 'real-ish' generated screenshots detected (not true Google Sheets captures):")
        for n in realish:
            print(f"  - docs/screenshots/{n}")

        print("\nNext steps (preferred):")
        print("  - Quick run: docs/screenshots/REAL_SCREENSHOTS_QUICKRUN.md")
        print("  - Shotlist + framing: docs/screenshots/REAL_SCREENSHOTS_SHOTLIST.md")
        print("  - Install helper: python3 scripts/install_real_screenshots.py --from ~/Desktop --check --optimize")
        print("  - Optional capture pack zip: python3 scripts/make_real_screenshot_capture_pack.py")
        print("  - Then re-check: python3 scripts/check_screenshots.py --fail-on-placeholders --fail-on-realish")

        if args.fail_on_realish:
            return 4
        return 0

    if required_pixels and (dim_unknown or dim_mismatch):
        rp = f"{required_pixels[0]}×{required_pixels[1]}"
        if dim_unknown:
            print(f"[screenshots] WARNING — could not determine pixel dimensions for: {', '.join(dim_unknown)} (required {rp})")
        if dim_mismatch:
            print(f"[screenshots] WARNING — pixel dimension mismatch (required {rp}):")
            for n in dim_mismatch:
                v = info.get(n) or {}
                w = v.get("width")
                h = v.get("height")
                got = f"{w}×{h}" if (w and h) else "(unknown)"
                print(f"  - docs/screenshots/{n} (got {got})")
        if args.fail_on_dim_mismatch:
            return 5

    print("[screenshots] OK — screenshots are not placeholders (and do not match known real-ish mocks).")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
